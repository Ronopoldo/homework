# Задача с сайта К.Полякова №5762 (https://kpolyakov.spb.ru/school/ege/gen.php?action=viewTopic&topicId=5762)
# Приблизительное время выполнения ≈ 4 секунды

def getDivs(n): # Объявляем функцию по поиску делителей
    divisors = set() # Объявляем множество, в котором будут храниться делители
    for i in range(1, int(n ** 0.5) + 1): # Перебираем все числа до момента корня числа – после него все делители будут соответствовать и их число будет таким же, как и до переломного момента
        if n % i == 0: # Проверка на делимость
            divisors.add(i) # Добавляем число ДО "перелома"
            divisors.add(n // i) # Добавляем аналогичное число ПОСЛЕ "перелома"
    return sorted(list(divisors)) # Возвращаем массив с делителями, предварительно убрав все дубликаты (т.к. используем тип set())




answers = [] # Создаём список ответов
#print(answers)
# for num1 in range(int(100000000 ** 0.5) + 1, int(1000000000 ** 0.5) + 1):
originNum = int(100000000 ** 0.5) + 1 # Минимальное число, которое мы берём – это кв. корень из 100'000'000 (число из условия); по поводу того, почему мы берём число под корень, смотреть в примечании
while len(answers) < 10: # Пока ответов меньше 10 (5+5), цикл работает
    if len(answers) < 5: # Условие для МИНИМАЛЬНЫХ ответов
        originNum +=1 # Прибавляем 1 к числу originNum, т.к для поиска минимальных ответов мы идём от меньшего к большему
    else: # Условие для МАКСИМАЛЬНЫХ ответов
        originNum -= 1 # Убавляем 1 от числа originNum, т.к для поиска максимальных ответов мы идём от большего к меньшему
    num = originNum**2 # Возводим число в квадрат, чтобы оно вошло в полуинтервал из условия (подробнее в примечании)
    divs = getDivs(num) # Получаем список со всеми делителями числа
    if len(divs) == 39 and originNum % 2 == 0: # Проверка на кол-во делителей и чётность ответа
        tmp = 38 # Временная переменная; используется для поиска наибольшего делителя
        divs = sorted(divs) # Сортируем делители по возрастанию, чтобы перебор работал
        while divs[tmp] % 2 == 0: # Перебираем числа до тех пор, пока не получим максимальный нечётный делитель (по усл.)
            tmp -= 1 # Убавляем индекс делителя до тех пор, пока он не будет нечётным
        maxDel = divs[tmp] # Присваиваем максимальный НЕЧЁТНЫЙ делитель
        answers.append([num, maxDel]) # Фиксируем ответ в формате [число, максимальный нечётный делитель]
        #print(f'{num} ПОДОШЛО!!')
        if len(answers) == 5: # Когда длина ответа становится равна 5 (т.е. мы закончили перебор МИНИМАЛЬНЫХ чисел), мы идём наоборот на самое большое значение для перебора МАКСИМАЛЬНЫХ чисел
            originNum = int(1000000000 ** 0.5) + 1 # Присваиваем originNum максимально возможное по условию задачи значение
    # print(num, answers)

print(*sorted(answers), sep='\n') # Вывод отсортированных ответов по возрастанию ._.



'''
ПРИМЕЧАНИЕ:
Существует теорема, которая твердит о том, что если у числа НЕЧЁТНОЕ количество делителей, то число является квадратом другого целого числа.

Именно поэтому все перебираемые числа у нас являются квадратом того числа, по которому мы ищем.
Полуинтервал, следовательно из этого, тоже возведён в корень (обе границы).

Доказательство:

Пусть число делителей нечётно. Это либо единица, либо больше единицы. Единица равна квадрату единицы - для неё утверждение справедливо.

Пусть теперь у числа n > 1 нечетное количество делителей. Разложим его на простые множители: n = (p1**a1)(p2**a2)...(pk**ak). Количество делителей этого числа (a1+1)(a2+1)...(ak+1) - нечётное. Следовательно, каждое из чисел (ai+1) - нечётно. Следовательно каждое число ai - чётно, то есть представимо в виде ai = 2*bi, где bi > 0.

Возьмём число m = (p1**b1)(p2**b2)...(pk**bk). Очевидно, что m*m == n


Источник с теоремой и док-вом: https://ru.stackoverflow.com/questions/1262598/Докажите-что-количество-делителей-квадрата-натурального-числа-число-нечетное
'''
